{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"girsh","text":"<p>The Git Installer is a Python script designed to automate the process of downloading, extracting, and installing binary releases from GitHub repositories. It also supports uninstalling previously installed binaries and caching version information to avoid redundant installations.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Download Releases -   Downloads assets from the latest GitHub release based on a regex pattern.</li> <li>Extract Archives Securely -   Supports native binaries as well as extraction of <code>.tar.gz</code>/<code>.tgz</code>, <code>.zip</code> and <code>.tar.bz2</code>/<code>.bz2</code> archives   with simple or pattern based search of the contained binary.</li> <li>Optional Renaming -   Allows you to specify a filter and renaming rule to select the correct binary from an extracted archive.</li> <li>Installation and Re-installation -   Automatically copies the binary to the appropriate binary folder based on user privileges   (e.g., /<code>usr/local/bin</code> for root, <code>~/.local/bin</code> for non-root). Use the <code>--reinstall</code> option to force a re-install.</li> <li>Uninstallation -   Provides an uninstall option (<code>--uninstall-all</code>) that removes all binaries installed by the script,   based on the cached information.   Individual packages can be uninstalled by removing them from the settings file and then running <code>girsh --uninstall</code>.</li> <li>Install logs -   The script tracks installed versions and binary names in a installed settings file,   avoiding unnecessary downloads and installations if the version hasn\u2019t changed.</li> <li>Pre- and post update/uninstall commands   Optional commands to be executed before update/uninstall and after update,   e.g. stop/start process</li> </ul> <p>For more detail see Config and Usage.</p>"},{"location":"config/","title":"Configuration","text":""},{"location":"config/#package-installation-settings","title":"Package installation settings","text":"<p>The general settings and a list of repositories are defined in a YAML config file (default <code>~/.config/girsh_config.yaml</code>). It can be created from template using the \"--edit\" option.</p> <p>The configuration file should have the following structure:</p> <p>```yaml title=\"girsh_config.yaml\" general:   # Optional: Base folder where binaries will be installed.   # For non-root users, this should usually be \"~/.local/bin\"   bin_base_folder: \"/usr/local/bin\"</p> <p># Optional: Path to the cache file where installed versions and binary names   # are stored. If not provided, it defaults to \"~/.cache/girsh/girsh.yaml\"   installed_file: \"/home/your_username/.installed/girsh/girsh.yaml\"</p> <p># Optional: Path to the download folder.   # If not provided, it defaults to \"~/.installed/girsh/downloads\"   download_dir: Path = \"/my/custom/bin\"</p> <p># Optional: Regex pattern to select the release asset, defaults to \".x86_64.(gz|zip)\\(\"   package_pattern: \".*aarch64.*(gz|zip)\\)\"</p> <p># Optional: Package base folder (for multi-file packages)   # If not provided, it defaults to \"~/.local/share/girsh\" or \"/opt/girsh\"   package_base_folder: \"/my/Packages\"</p> <p>repositories:   # Dictionary of git repositories from which the released binary should be installed   owner/repository-name:     # Optional: Comment about the installed package     comment: This is an interesting tool     # Optional: Regex pattern to select the release asset, defaults to \".(gz|zip)\"     package_pattern: str = \".amd_64.*gz\"     # Optional: Regex pattern to filter the extracted files to identify the binary.     # Optional: Regex pattern to filter the extracted files to identify the binary.     # If the same file name is present in multiple folders, include a (sub-)path.     filter_pattern: \"bin/my_binary$\"     # Optional: Renaming rule. If provided, the matching binary will be renamed     # to this name before installation.     binary_name: \"my-renamed-binary\"     # Optional: Pin to specific version (git tag)     version: v0.41.2     # Optional: Flag that the packe is not a single binary     multi_file: true     # Optional: Pre-update/uninstall commands     pre_update_commands:       - echo \"Pre-update command 1\"       - \"%confirm_default_no% Continue to install?\"       - \"%stop_processes% my-renamed-binary\"     # Optional: Post-install/update commands     post_update_commands:       - echo \"Post-update command 1\"       - echo \"Post-update command 2\"     # Optional: Download URL template using <code>{version}</code> as a placeholder for the release tag     download_url: https://package/download/{version}/linux-x64/stable</p> <pre><code>\n### Commands\n\n#### Option to continue in case of failure\n\nBy default the installation or update for a repository will fail if one of the defined commands returns non-zero exit code.\nIf the command is prefixed with a `|`, then errors for this command are ignored.\n\nExample: `|sh -c 'exit 42'`\n\n#### Option to run command in a shell\n\nBy default the command is executed as command sequence.\nIf a shell is required, e.g. for using pipes or conditions, it can be enabled with the prefix `*`.\n\nExample: `*zellij kill-all-sessions || echo done`\n\nThis option can be combined with the \"continue on failure\":\n\nExample: `|*my_command | grep dummy`\n\n#### Comments\n\nCommands can be disabled as comment using `#` prefix, also within an explicit string.\n\nExample:\n\n```yaml\npre_update_commands:\n  -  #echo \"Pre-update command 1\"\n  - \"#%confirm_default_no% Continue to install?\"\n</code></pre>"},{"location":"config/#macros","title":"Macros","text":"<p>The pre- and post-update commands also support some macros. Macro commands must be at the beginning of the command string and are encapsulated with <code>%</code>, e.g. <code>%my_macro%</code>. The string after the macro command name is passed to the macro function and must be separated by one space from the macro command.</p> <p>If the macro returns <code>False</code>, the command execution and further processing of the related repository is cancelled with an error.</p> <ul> <li>Supported macros:</li> <li><code>%confirm_default_yes%</code><ul> <li>Prompts the user with a yes/no question and returns True if the user doesn't explicitly answers \"n\" (no).</li> <li>Argument: Question string.</li> <li>Example: <code>%confirm_default_yes% Install program?</code></li> </ul> </li> <li><code>%confirm_default_no%</code><ul> <li>Prompts the user with a yes/no question and returns True if the user explicitly answers \"y\" (yes).</li> <li>Argument: Question string.</li> <li>Example: <code>%confirm_default_no% Kill program?</code></li> </ul> </li> <li><code>%stop_processes%</code><ul> <li>Terminate all running processes for of given program.</li> <li>Argument: program name</li> <li>Example: <code>%stop_processes% my_program</code></li> </ul> </li> </ul>"},{"location":"modules/","title":"main","text":""},{"location":"modules/#girsh","title":"<code>girsh</code>","text":""},{"location":"modules/#girsh.elevate_privileges","title":"<code>elevate_privileges()</code>","text":"<p>Elevate the privileges of the current process to root using sudo. If the current process is not running as the root user, this function will re-run the script with elevated privileges by invoking sudo. Raises:     OSError: If there is an error executing the sudo command.</p>"},{"location":"modules/#girsh.main","title":"<code>main()</code>","text":"<p>The main entry point for the application.</p> <p>This function processes command-line arguments, manages configurations, and orchestrates the execution of various operations such as editing configurations, cleaning the downloads folder, showing installed items, uninstalling repositories, and processing repositories for installation.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Exit code indicating the result of the operation.  - 0: Success  - 1: Uninstall operation failed  - 3: No repositories installed  - Other non-zero values indicate errors or specific conditions</p>"},{"location":"modules/#girsh.set_logger_level","title":"<code>set_logger_level(verbosity)</code>","text":"<p>Set the logger level based on the verbosity argument.</p> <p>Parameters:</p> Name Type Description Default <code>verbosity</code> <code>int</code> <p>The verbosity level (0-3).</p> required"},{"location":"modules/#girsh.show_summary","title":"<code>show_summary(install_summary, uninstall_summary)</code>","text":"<p>Display a summary of the repository processing results.</p> <p>Parameters:</p> Name Type Description Default <code>install_summary</code> <code>dict[RepoResult, int]</code> <p>A dictionary where the keys are RepoResult instances and the values are counts of occurrences.</p> required <code>uninstall_summary</code> <code>dict[RepoResult, int]</code> <p>A dictionary where the keys are RepoResult instances and the values are counts of occurrences.</p> required"},{"location":"modules/#core","title":"core","text":""},{"location":"modules/#core.config","title":"<code>core.config</code>","text":""},{"location":"modules/#core.config.edit_config","title":"<code>edit_config(config_path)</code>","text":"<p>Open the specified config file in the user's default terminal editor.</p> <p>Parameters:</p> Name Type Description Default <code>config_path</code> <code>Path</code> <p>Path to the configuration file to edit.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>error code</p>"},{"location":"modules/#core.config.get_arguments","title":"<code>get_arguments()</code>","text":"<p>Parse the command line arguments</p> <p>Returns:</p> Type Description <code>Namespace</code> <p>argparse.Namespace: Parsed command line arguments</p>"},{"location":"modules/#core.config.load_yaml_config","title":"<code>load_yaml_config(file_path)</code>","text":"<p>Load and parse the YAML configuration file and update the general and repositories config.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>Path to the YAML configuration file.</p> required <p>Returns:</p> Type Description <code>tuple[General, dict[str, Repository]]</code> <p>tuple[General, dict[str, Repository]]: A tuple containing the updated General instance and a dictionary mapping repository names to Repository instances.</p>"},{"location":"modules/#core.config.update_general_config","title":"<code>update_general_config(general_config, data)</code>","text":"<p>Update a General dataclass instance with values from a dictionary.</p> <p>This function looks for a 'general' key in the provided data and updates the configuration fields if they exist, triggering any type conversions defined in setattr.</p> <p>Parameters:</p> Name Type Description Default <code>general_config</code> <code>General</code> <p>The current configuration instance.</p> required <code>data</code> <code>dict</code> <p>Dictionary containing configuration data, e.g., from a YAML file.</p> required <p>Returns:</p> Name Type Description <code>General</code> <code>General</code> <p>The updated configuration instance.</p>"},{"location":"modules/#core.config.update_repositories_config","title":"<code>update_repositories_config(repo_config, data, default_pattern)</code>","text":"<p>Update repository configurations using YAML data.</p> <p>This function extracts repository configurations from the \"repositories\" key in the provided YAML data. For each repository, it creates a new Repository instance (or a default one if the configuration is None) and ensures that a default package pattern is set if missing.</p> <p>Parameters:</p> Name Type Description Default <code>repo_config</code> <code>dict[str, Repository]</code> <p>Existing repository configuration mapping.</p> required <code>data</code> <code>dict</code> <p>Loaded configuration data from a YAML file.</p> required <code>default_pattern</code> <code>str</code> <p>Default package pattern to use when not specified.</p> required <p>Returns:</p> Type Description <code>dict[str, Repository]</code> <p>dict[str, Repository]: The updated repository configuration mapping.</p>"},{"location":"modules/#core.files","title":"<code>core.files</code>","text":""},{"location":"modules/#core.files.clean_downloads_folder","title":"<code>clean_downloads_folder(download_dir)</code>","text":"<p>Remove the downloads folder and exit.</p> <p>Parameters:</p> Name Type Description Default <code>download_dir</code> <code>Path</code> <p>The download folder path</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>error code</p>"},{"location":"modules/#core.files.copy_to_bin","title":"<code>copy_to_bin(binary_path, bin_base_folder, binary_name=None)</code>","text":"<p>Copy the binary file to the system or user binary directory.</p> <p>Parameters:</p> Name Type Description Default <code>binary_path</code> <code>Path</code> <p>Path to the binary file to be copied.</p> required <code>bin_base_folder</code> <code>Path</code> <p>The binaries base folder path.</p> required <code>binary_name</code> <code>str | None</code> <p>Optional binary name, defaults to the name from binary path</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Path</code> <code>Path</code> <p>Path to installed binary file</p>"},{"location":"modules/#core.files.download_github_release","title":"<code>download_github_release(url, package_pattern, output_dir, release_info=None, download_url=None)</code>","text":"<p>Download a matching release asset from a GitHub repository.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>GitHub API release URL.</p> required <code>package_pattern</code> <code>str</code> <p>Regex pattern to match the desired asset.</p> required <code>output_dir</code> <code>Path</code> <p>Directory to save the downloaded asset.</p> required <code>release_info</code> <code>dict[Any, Any] | None</code> <p>Optionally provide release JSON to avoid duplicate API calls.</p> <code>None</code> <code>download_url</code> <code>str | None</code> <p>Optional download URL template</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[Path, str] | None</code> <p>tuple[Path, str] | None: Tuple of path to the downloaded file and the release tag, or None if no match.</p>"},{"location":"modules/#core.files.download_package","title":"<code>download_package(download_url, output_dir, filename=None)</code>","text":"<p>Downloads a file from the given URL and saves it to the specified output directory.</p> <p>Parameters:</p> Name Type Description Default <code>download_url</code> <code>str</code> <p>The URL to download the file from.</p> required <code>output_dir</code> <code>Path</code> <p>The directory where the downloaded file will be saved.</p> required <code>filename</code> <code>str | None</code> <p>The name to save the file as. If not provided, the filename will be                              extracted from the Content-Disposition header or the URL.</p> <code>None</code> <p>Returns:</p> Type Description <code>Path | None</code> <p>Path | None: The path to the downloaded file, or None if the download failed.</p>"},{"location":"modules/#core.files.extract_archive","title":"<code>extract_archive(file_path, extract_to, package_name)</code>","text":"<p>Extract the archive based on its extension and return the common top-level folder name if one is detected. For pure bz2 files, extraction is done directly.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>Path</code> <p>The path to the archive.</p> required <code>extract_to</code> <code>Path</code> <p>The base extraction directory.</p> required <code>package_name</code> <code>str</code> <p>The package folder name used when a common folder is not found.</p> required <p>Returns:</p> Type Description <code>str | None</code> <p>str | None: The common top-level folder name if detected; otherwise, None.</p>"},{"location":"modules/#core.files.extract_bz2_archive","title":"<code>extract_bz2_archive(file_path, extract_to, package_name)</code>","text":"<p>Extract a pure bz2 compressed file (non-tar archive) into a subfolder.</p> <p>The function decompresses a .bz2 file and writes the output into a folder named after package_name within extract_to.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>Path</code> <p>The path to the .bz2 file.</p> required <code>extract_to</code> <code>Path</code> <p>The base directory where the file should be extracted.</p> required <code>package_name</code> <code>str</code> <p>The name for the package folder.</p> required"},{"location":"modules/#core.files.extract_package","title":"<code>extract_package(file_path, extract_to, package_name)</code>","text":"<p>Extract a compressed package file into a controlled folder structure. This function now delegates the extraction process to <code>extract_archive</code> to reduce complexity.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>Path</code> <p>The path to the compressed package file.</p> required <code>extract_to</code> <code>Path</code> <p>The base directory where the package should be extracted.</p> required <code>package_name</code> <code>str</code> <p>The name for the package folder.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p>"},{"location":"modules/#core.files.extract_tar_archive","title":"<code>extract_tar_archive(archive, base)</code>","text":"<p>Extract members from a tar archive into the given base directory, skipping unsafe paths.</p> <p>Parameters:</p> Name Type Description Default <code>archive</code> <code>TarFile</code> <p>The tar archive to extract.</p> required <code>base</code> <code>Path</code> <p>The base directory where files will be extracted.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p>"},{"location":"modules/#core.files.extract_zip_archive","title":"<code>extract_zip_archive(archive, base)</code>","text":"<p>Extract members from a zip archive into the given base directory, skipping unsafe paths.</p> <p>Parameters:</p> Name Type Description Default <code>archive</code> <code>ZipFile</code> <p>The zip archive to extract.</p> required <code>base</code> <code>Path</code> <p>The base directory where files will be extracted.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p>"},{"location":"modules/#core.files.find_binary","title":"<code>find_binary(extract_dir, filter_pattern)</code>","text":"<p>Search for the binary in the extracted directory and rename it if necessary.</p> <p>Parameters:</p> Name Type Description Default <code>extract_dir</code> <code>Path</code> <p>The directory where the package was extracted.</p> required <code>filter_pattern</code> <code>str | None</code> <p>A pattern to filter and match the binary file.</p> required <p>Returns:</p> Type Description <code>Path | None</code> <p>Path | None: The path to the binary if found, or None if no binary is found.</p>"},{"location":"modules/#core.files.get_common_prefix","title":"<code>get_common_prefix(names)</code>","text":"<p>Determine the common top-level folder from a list of archive member names.</p> <p>Parameters:</p> Name Type Description Default <code>names</code> <code>list[str]</code> <p>List of member paths (as strings) from the archive.</p> required <p>Returns:</p> Type Description <code>str | None</code> <p>str | None: The common top-level folder if all names share one; otherwise, None.</p>"},{"location":"modules/#core.files.get_filename_from_cd","title":"<code>get_filename_from_cd(content_disposition)</code>","text":"<p>Extract filename from Content-Disposition header.</p> <p>Parameters:</p> Name Type Description Default <code>content_disposition</code> <code>str</code> <p>The Content-Disposition header value.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str | None</code> <p>The filename if found, otherwise None.</p>"},{"location":"modules/#core.files.is_safe_path","title":"<code>is_safe_path(base, target)</code>","text":"<p>Check if the resolved target path is within the resolved base directory to prevent path traversal.</p> <p>Parameters:</p> Name Type Description Default <code>base</code> <code>Path</code> <p>The intended base directory.</p> required <code>target</code> <code>Path</code> <p>The target path to be validated.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the target is within the base directory; False otherwise.</p>"},{"location":"modules/#core.files.move_to_packages","title":"<code>move_to_packages(package_source, package_base_folder, bin_base_folder, binary_path, binary_name=None)</code>","text":"<p>Move the extracted package to the packages base folder and symlink the binary file to the system or user binary directory.</p> <p>Parameters:</p> Name Type Description Default <code>package_source</code> <code>Path</code> <p>Path to the extracted package</p> required <code>package_base_folder</code> <code>Path</code> <p>The base package folder path.</p> required <code>bin_base_folder</code> <code>Path</code> <p>The binaries base folder path.</p> required <code>binary_path</code> <code>Path</code> <p>Path to the binary file to be linked.</p> required <code>binary_name</code> <code>str | None</code> <p>Optional symlink name, defaults to the name from binary path</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Path</code> <code>Path</code> <p>Path to installed binary file</p>"},{"location":"modules/#core.installed","title":"<code>core.installed</code>","text":""},{"location":"modules/#core.installed.get_comment","title":"<code>get_comment(repo, repositories)</code>","text":"<p>Get the comment from the repository config. If the repository is not found, return a default message.</p> <p>Args     repo (str): Name of the repository</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Comment from repository config</p>"},{"location":"modules/#core.installed.load_installed","title":"<code>load_installed(installed_file)</code>","text":"<p>Load the version installed from a YAML file.</p> <p>Parameters:</p> Name Type Description Default <code>installed_file</code> <code>Path</code> <p>Path to the installed file.</p> required <p>Returns:</p> Type Description <code>dict[str, dict]</code> <p>dict[str, str]: Dict of installed software details.</p>"},{"location":"modules/#core.installed.save_installed","title":"<code>save_installed(installed_file, data)</code>","text":"<p>Save the version installed to a YAML file.</p> <p>Parameters:</p> Name Type Description Default <code>installed_file</code> <code>Path</code> <p>Path to the installed file.</p> required <code>data</code> <code>dict[Any, Any]</code> <p>Version installed data to save.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>error code</p>"},{"location":"modules/#core.installed.show_installed","title":"<code>show_installed(data, repositories)</code>","text":"<p>Display installed binaries in a table format with auto-fitted column widths.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[Any, Any]</code> <p>Dictionary containing installed binaries with metadata.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Error code (0 for success).</p>"},{"location":"modules/#core.repos","title":"<code>core.repos</code>","text":""},{"location":"modules/#core.repos.check_repo_release","title":"<code>check_repo_release(repo, target_version, current_version, reinstall)</code>","text":"<p>Check the release information of a repository and determine the appropriate action.</p> <p>This function fetches release information for a given repository from GitHub, checks if a new version is available, and determines whether to skip, reinstall, or proceed with the release.</p> <p>Parameters:</p> Name Type Description Default <code>repo</code> <code>str</code> <p>The name of the repository to check.</p> required <code>target_version</code> <code>str | None</code> <p>The target version to check for. If None, the latest version is used.</p> required <code>current_version</code> <code>str | None</code> <p>The currently installed version. If None, it assumes no version is installed.</p> required <code>reinstall</code> <code>bool</code> <p>Whether to force reinstallation even if the current version matches the target version.</p> required <p>Returns:</p> Type Description <code>tuple[RepoResult, dict[Any, Any]]</code> <p>RepoResult | dict[Any, Any]: - A dictionary containing release information if a new version is available or reinstall is forced. - A RepoResult enum value indicating the action taken (e.g., skipped or install_failed).</p>"},{"location":"modules/#core.repos.fetch_release_info","title":"<code>fetch_release_info(repo, version, reinstall)</code>","text":"<p>Fetch the release information for a given repository from GitHub.</p> <p>Parameters:</p> Name Type Description Default <code>repo</code> <code>str</code> <p>The repository identifier, in the format 'owner/repo'.</p> required <code>version</code> <code>str | None</code> <p>The repository version</p> required <code>reinstall</code> <code>bool</code> <p>A flag to force reinstall even if no new version is detected.</p> required <p>Returns:</p> Type Description <code>dict[Any, Any] | None</code> <p>dict | None: The release information in JSON format, or None if an error occurs.</p>"},{"location":"modules/#core.repos.is_new_version","title":"<code>is_new_version(installed_tag, tag, reinstall)</code>","text":"<p>Determine if the current version is different from the installed version or if a reinstall is forced.</p> <p>Parameters:</p> Name Type Description Default <code>installed_tag</code> <code>str | None</code> <p>The installed version of the repository.</p> required <code>tag</code> <code>str</code> <p>The new version's tag name from the release info.</p> required <code>reinstall</code> <code>bool</code> <p>A flag to force reinstall even if no new version is detected.</p> required <p>Returns:</p> Name Type Description <code>RepoResult</code> <code>RepoResult</code> <p>Target action based on version info and reinstall flag</p>"},{"location":"modules/#core.repos.process_repositories","title":"<code>process_repositories(repositories, general, installed, reinstall, dry_run=False)</code>","text":"<p>Processes a list of repositories, installs or updates them if necessary, and saves the updated installation data.</p> <p>Parameters:</p> Name Type Description Default <code>repositories</code> <code>Mapping[str, RepositoryConfig]</code> <p>A dictionary of repository names and their corresponding Repository objects.</p> required <code>general</code> <code>GeneralConfig</code> <p>General configuration settings.</p> required <code>installed</code> <code>dict[str, dict]</code> <p>A dictionary containing the current installation data of the repositories.</p> required <code>reinstall</code> <code>list[str]</code> <p>List of repositories to reinstall.</p> required <code>dry_run</code> <code>bool</code> <p>A flag to perform a dry run (no changes are actually made). Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict[str, dict]</code> <p>dict[str, dict] | None: Updated install data or None</p> <code>dict[RepoResult, int]</code> <p>dict[RepoResult, int]: Summary of the installation process</p> <p>Logs: - Warnings and errors related to repository processing. - A summary of the installation or update process, including the number of repositories processed for each result type.</p>"},{"location":"modules/#core.repos.process_repository","title":"<code>process_repository(repo, repo_config, general, installed_tag, reinstall=False, dry_run=False)</code>","text":"<p>Process a single repository by checking for updates, downloading the latest release, extracting, optionally renaming the binary, and installing it. Updates the installed with the latest version information if a new version is installed.</p> <p>Parameters:</p> Name Type Description Default <code>repo</code> <code>str</code> <p>The repository identifier, in the format 'owner/repo'.</p> required <code>repo_config</code> <code>RepositoryConfig</code> <p>The repository configuration, containing version info and other settings.</p> required <code>general</code> <code>GeneralConfig</code> <p>General configuration settings.</p> required <code>installed_tag</code> <code>str | None</code> <p>Tag of installed version.</p> required <code>reinstall</code> <code>bool</code> <p>A flag to force reinstall even if the current version is up-to-date (default: False).</p> <code>False</code> <code>dry_run</code> <code>bool</code> <p>A flag to simulate the process without installing the binary (default: False).</p> <code>False</code> <p>Returns:</p> Type Description <code>tuple[RepoResult, dict[str, str]]</code> <p>tuple[RepoResult, dict[str, str]]: Result of repo installation, Repo installation data</p>"},{"location":"modules/#core.repos.remove_binary","title":"<code>remove_binary(repo, info, dry_run)</code>","text":"<p>Remove the binary file associated with a repository.</p> <p>Parameters:</p> Name Type Description Default <code>repo</code> <code>str</code> <p>Repository name.</p> required <code>info</code> <code>dict[Any, Any]</code> <p>Installation info containing 'path' and 'binary'.</p> required <code>dry_run</code> <code>bool</code> <p>Simulate removal if True.</p> required"},{"location":"modules/#core.repos.remove_package","title":"<code>remove_package(repo, info, dry_run)</code>","text":"<p>Remove the package directory if it exists.</p> <p>Parameters:</p> Name Type Description Default <code>repo</code> <code>str</code> <p>Repository name.</p> required <code>info</code> <code>dict[Any, Any]</code> <p>Installation info that may contain 'package_path'.</p> required <code>dry_run</code> <code>bool</code> <p>Simulate removal if True.</p> required"},{"location":"modules/#core.repos.uninstall","title":"<code>uninstall(repositories, installed, dry_run=False)</code>","text":"<p>Uninstall binaries which are not present in the repositories config anymore. If repositories is empty, all binaries will be uninstalled. This function will also remove the package folder if it exists.</p> <p>Parameters:</p> Name Type Description Default <code>repositories</code> <code>list[str]</code> <p>A list of repository names.</p> required <code>installed</code> <code>dict[Any, Any]</code> <p>installed tracking installed versions and binaries.</p> required <code>dry_run</code> <code>bool</code> <p>A flag to simulate the process without removing the binary (default: False).</p> <code>False</code>"},{"location":"modules/#core.repos.uninstall_binary","title":"<code>uninstall_binary(repo, install_data, dry_run)</code>","text":"<p>Uninstalls a binary file associated with a given repository.</p> <p>Parameters:</p> Name Type Description Default <code>repo</code> <code>str</code> <p>The name of the repository associated with the binary.</p> required <code>install_data</code> <code>dict</code> <p>A dictionary containing install information about the binary.</p> required <code>dry_run</code> <code>bool</code> <p>If True, simulates the uninstallation process without making any changes.</p> required <p>Returns:</p> Name Type Description <code>RepoResult</code> <code>RepoResult</code> <p>An enumeration indicating the result of the uninstallation process. Possible values:     - RepoResult.dry_run_uninstall: Indicates a successful dry-run.     - RepoResult.uninstalled: Indicates the binary was successfully uninstalled.     - RepoResult.uninstall_failed: Indicates the uninstallation failed due to permission issues.</p>"},{"location":"usage/","title":"Usage","text":"<pre><code>usage: girsh [-h] [-r BINARY [BINARY ...] | -u | --uninstall-all | --clean | -s | -e] [-c CONFIG] [-d] [-v] [-g] [-V]\n\nGit Install Released Software Helper\n\noptions:\n  -h, --help            show this help message and exit\n  -r BINARY [BINARY ...], --reinstall BINARY [BINARY ...]\n                        Force re-installation even if version unchanged\n  -u, --uninstall       Uninstall previously installed binary if not present in config anymore\n  --uninstall-all       Uninstall all previously installed binaries\n  --clean               Remove the downloads folder and exit\n  -s, --show            Show config and currently installed binaries\n  -e, --edit            Open the config file in the default editor\n  -c CONFIG, --config CONFIG\n                        Path to config file, defaults to ~/.config/girsh.yaml\n  -d, --dry-run         Run without actually installing or removing any files.\n  -v, --verbose         Increase output verbosity (up to 3 times)\n  -g, --global          Install as root at system level\n  -V, --version         show program's version number and exit\n</code></pre>"},{"location":"usage/#functions","title":"Functions","text":""},{"location":"usage/#install-or-update-packages","title":"Install or update packages","text":"<p>Run the script with your default configuration file:</p> <pre><code>girsh\n</code></pre> <p>This command processes each repository entry in the configuration, downloads the latest release asset (if a new version is available), extracts the asset, renames it (if configured), and installs the binary to the specified bin_base_folder.</p> <p>Example:</p> <pre><code>$ girsh\n\nmrjackwills/oxker: skipped\njesseduffield/lazydocker updated from v0.23.0 to v0.24.1\ncontainers/podman-tui installed version v1.4.0\n===============================\nSummary:\n  skipped: 1\n  updated: 1\n  installed: 1\n</code></pre>"},{"location":"usage/#show-installed-programs","title":"Show installed programs","text":"<p>Example:</p> <pre><code>$ girsh --show\n\nCurrently installed binaries:\n+--------------------------+----------------------------------------------+------------+---------+\n| Repository               | Comment                                      | Binary     | Tag     |\n+--------------------------+----------------------------------------------+------------+---------+\n| containers/podman-tui    | Go TUI for Podman environment.               | podman-tui | v1.4.0  |\n| jesseduffield/lazydocker | Go TUI for both docker and docker-compose    | lazydocker | v0.24.1 |\n| mrjackwills/oxker        | Rust tui to view &amp; control docker containers | oxker      | v0.10.0 |\n+--------------------------+----------------------------------------------+------------+---------+\n</code></pre>"},{"location":"usage/#use-custom-config-file","title":"Use custom config file","text":"<p>Run the script with your custom configuration file:</p> <pre><code>girsh --config my_config.yaml\n</code></pre>"},{"location":"usage/#force-re-installation","title":"Force Re-installation","text":"<p>To force re-installation of a binary even if the installed version matches the latest release, use the <code>--reinstall</code> option:</p> <pre><code>girsh --reinstall\n</code></pre>"},{"location":"usage/#uninstall-installed-binaries","title":"Uninstall Installed Binaries","text":"<p>If some repository has been removed from the config file and the binary should be removed, use the <code>--uninstall</code> option:</p> <pre><code>girsh --uninstall\n</code></pre> <p>To uninstall all binaries installed by the script (tracked in the installation logs), use the <code>--uninstall-all</code> option:</p> <pre><code>girsh --uninstall-all\n</code></pre> <p>This command will remove all binaries from the target installation folder that are tracked in the installation logs and then clear the installation logs.</p>"},{"location":"usage/#clean-temporary-downloads","title":"Clean Temporary Downloads","text":"<p>To remove the downloads folder (used for temporary storage) and exit:</p> <pre><code>girsh --clean\n</code></pre>"},{"location":"usage/#script-output","title":"Script output","text":"<p>The script uses Loguru for logging. By default, it logs success messages to stdout. For more detailed output the verbosity can be increase:</p> <pre><code>girsh -v\n</code></pre> <p>The verbosity can be increased up to 3 time, e.g. <code>girsh -vvv</code> for trace logs.</p>"},{"location":"usage/#example-workflow","title":"Example Workflow","text":"<p>Create your <code>girsh_config.yaml</code> from template.</p> <pre><code>girsh --edit\n\nThe file '/home/user_name/.config/girsh.yaml' does not exist. Do you want to create it? (y/N):y\n</code></pre> <p>Run the installer:</p> <pre><code>girsh\n</code></pre> <p>To update binaries when new versions are released, simply re-run the installer. The script will check the installation logs and only download and install if there's a version change(unless <code>--reinstall</code> is specified).</p> <p>If you want to remove all installed binaries:</p> <pre><code>girsh --uninstall-all\n</code></pre> <p>To clean up temporary downloads:</p> <pre><code>girsh --clean\n</code></pre>"}]}